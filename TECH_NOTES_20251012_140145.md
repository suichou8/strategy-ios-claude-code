# iOS 技术理解笔记

本文档记录项目开发过程中的重要技术概念和深度理解，方便后续深挖思考。

---

## 目录

- [@Observable 状态管理详解](#observable-状态管理详解)
- [待补充...](#)

---

## @Observable 状态管理详解

### 概述

`@Observable` 是 Apple 在 iOS 17 引入的官方状态管理方案，来自 `Observation` 框架，用于替代旧的 `ObservableObject` 协议。

```swift
import Observation  // iOS 17+ 系统自带，无需第三方库
```

### 核心问题：如何统一状态管理？

#### 旧方案的问题（iOS 13-16）

**需要区分两种情况**：

```swift
class AuthManager: ObservableObject {
    @Published var isAuthenticated: Bool = false
}

struct ParentView: View {
    // 情况1：创建实例 → 必须用 @StateObject
    @StateObject private var authManager = AuthManager()
    // 为什么？因为需要视图拥有这个对象的生命周期

    var body: some View {
        ChildView(authManager: authManager)
    }
}

struct ChildView: View {
    // 情况2：接收传递的实例 → 必须用 @ObservedObject
    @ObservedObject var authManager: AuthManager
    // 为什么？因为不能创建新实例，只是观察已有对象

    var body: some View {
        Text(authManager.isAuthenticated ? "已登录" : "未登录")
    }
}
```

**问题总结**：
- ❌ 容易搞混：什么时候用 `@StateObject`？什么时候用 `@ObservedObject`？
- ❌ 如果用错了，会导致对象被意外释放或重复创建
- ❌ 代码不统一，增加认知负担

#### 新方案如何统一（iOS 17+）

**`@Observable` 统一使用 `@State`**：

```swift
@Observable
class AuthManager {
    var isAuthenticated: Bool = false  // 不需要 @Published
}

struct ParentView: View {
    // 统一用 @State，无论创建还是传递
    @State private var authManager = AuthManager()

    var body: some View {
        ChildView()
            .environment(authManager)  // 通过 environment 传递
    }
}

struct ChildView: View {
    // 也是用类似的方式接收，不需要区分
    @Environment(AuthManager.self) var authManager

    var body: some View {
        Text(authManager.isAuthenticated ? "已登录" : "未登录")
    }
}
```

### 技术原理：@Observable 如何做到的？

#### 旧方案的实现机制

```swift
class AuthManager: ObservableObject {
    @Published var isAuthenticated: Bool = false
}

// @Published 底层实现：
// 1. 每个属性有一个 Publisher（Combine 框架）
// 2. 属性变化 → 发送通知 → SwiftUI 重新渲染
// 3. ObservableObject 协议要求实现 objectWillChange
```

**问题**：基于 Combine 框架，需要手动管理订阅和生命周期，所以需要 `@StateObject` 和 `@ObservedObject` 区分。

#### 新方案的实现机制

```swift
@Observable
class AuthManager {
    var isAuthenticated: Bool = false
}

// @Observable 宏展开后（编译器自动生成）：
class AuthManager {
    @ObservationTracked  // 编译器生成
    var isAuthenticated: Bool = false

    // 编译器自动生成追踪代码：
    internal let _$observationRegistrar = ObservationRegistrar()

    internal nonisolated func access<Member>(
        keyPath: KeyPath<AuthManager, Member>
    ) {
        _$observationRegistrar.access(self, keyPath: keyPath)
    }

    internal nonisolated func withMutation<Member, T>(
        keyPath: KeyPath<AuthManager, Member>,
        _ mutation: () throws -> T
    ) rethrows -> T {
        try _$observationRegistrar.withMutation(of: self, keyPath: keyPath, mutation)
    }
}
```

**关键点**：
1. **自动追踪**：编译器自动生成属性访问和修改的追踪代码
2. **精确观察**：只追踪实际使用的属性，不是整个对象
3. **统一管理**：SwiftUI 内部统一管理所有观察，不需要开发者区分

### 优势对比

| 特性 | @ObservableObject (旧) | @Observable (新) |
|------|----------------------|------------------|
| 需要继承协议 | ✅ 是 | ❌ 否 |
| 属性需要标记 | ✅ @Published | ❌ 自动追踪 |
| 视图中使用 | @StateObject/@ObservedObject | @State (统一) |
| 性能 | 较差（全量刷新） | 更好（精确刷新） |
| 代码简洁度 | 中等 | ⭐️ 高 |
| 实现方式 | 手动协议 + @Published | 编译器宏自动生成 |
| 追踪粒度 | 对象级别 | 属性级别 |
| 生命周期 | 开发者手动管理 | SwiftUI 自动管理 |

### 实际使用场景对比

#### 场景1：单例模式

**旧方案**：
```swift
class AuthManager: ObservableObject {
    static let shared = AuthManager()
    @Published var isAuthenticated: Bool = false
}

struct View1: View {
    @ObservedObject var auth = AuthManager.shared  // 必须用 @ObservedObject
    // 不能用 @StateObject，因为会创建新实例
}

struct View2: View {
    @ObservedObject var auth = AuthManager.shared  // 也要用 @ObservedObject
}
```

**新方案**：
```swift
@Observable
class AuthManager {
    static let shared = AuthManager()
    var isAuthenticated: Bool = false
}

struct View1: View {
    // 可以不用任何属性包装器，直接访问
    var body: some View {
        Text(AuthManager.shared.isAuthenticated ? "已登录" : "未登录")
    }
    // SwiftUI 会自动追踪 AuthManager.shared.isAuthenticated 的变化
}

struct View2: View {
    // 或者用 @State 包装（推荐，更清晰）
    @State private var auth = AuthManager.shared

    var body: some View {
        Text(auth.isAuthenticated ? "已登录" : "未登录")
    }
}
```

#### 场景2：完整的应用示例

```swift
// AuthManager.swift
@Observable
public final class AuthManager {
    public static let shared = AuthManager()
    public private(set) var isAuthenticated: Bool = false

    public func login() {
        isAuthenticated = true  // 修改属性
        // SwiftUI 会自动通知所有使用这个属性的视图
    }
}

// App.swift
@main
struct CatchTrendApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}

// ContentView.swift
struct ContentView: View {
    // 不需要任何属性包装器！
    var body: some View {
        VStack {
            if AuthManager.shared.isAuthenticated {
                Text("已登录")
            } else {
                LoginButton()
            }
        }
    }
    // SwiftUI 自动追踪 isAuthenticated 的变化
}

// LoginButton.swift
struct LoginButton: View {
    var body: some View {
        Button("登录") {
            AuthManager.shared.login()
            // isAuthenticated 变为 true
            // → ContentView 自动刷新
            // → 显示 "已登录"
        }
    }
}
```

### 为什么能统一？

**核心原因**：

1. **编译时代码生成**
   - `@Observable` 宏在编译时自动生成追踪代码
   - 开发者只需要写业务逻辑，编译器处理底层实现

2. **运行时自动注册**
   - SwiftUI 在渲染时自动注册对属性的依赖
   - 不需要手动订阅/取消订阅

3. **精确失效**
   - 只有被使用的属性变化时才触发视图更新
   - 旧方案是整个对象变化就全部更新

4. **统一生命周期管理**
   - SwiftUI 自动管理对象的生命周期
   - 开发者不需要区分创建和引用的场景

### 与本项目的结合

在 `NetworkKit/AuthManager.swift` 中的应用：

```swift
import Foundation
import Security
import Observation  // ← 必须导入

@Observable  // ← 使用宏
public final class AuthManager {
    public static let shared = AuthManager()

    // 这些属性变化时，使用它的 SwiftUI 视图会自动更新
    public private(set) var isAuthenticated: Bool = false
    public private(set) var currentUsername: String?

    // private(set) 表示：外部只能读，内部可以写
    // 这样保证状态只能通过 AuthManager 的方法修改

    public func saveAuth(token: String, username: String) throws {
        // ... 保存到 Keychain

        // 修改状态，所有依赖的视图自动更新
        isAuthenticated = true
        currentUsername = username
    }
}
```

### 兼容性考虑

**最低版本要求**：iOS 17.0+

如果需要支持更低版本，需要使用旧方案：

```swift
// iOS 13-16 兼容方案
class AuthManager: ObservableObject {
    @Published var isAuthenticated: Bool = false
    @Published var currentUsername: String?
}
```

本项目在 `Package.swift` 中已声明最低版本为 iOS 17：

```swift
platforms: [
    .iOS(.v17)
]
```

### 总结

**`@Observable` 如何抹平差异？**

1. **编译器魔法**：宏自动生成追踪代码，开发者无需关心
2. **运行时智能**：SwiftUI 自动注册依赖，自动管理生命周期
3. **统一接口**：所有状态都用 `@State`，或直接访问
4. **精确更新**：只更新真正需要的视图

**简单说**：旧方案需要开发者手动区分和管理，新方案让编译器和运行时自动完成这些工作，所以不需要区分了。

### 深入学习资源

- [WWDC 2023: Discover Observation in SwiftUI](https://developer.apple.com/videos/play/wwdc2023/10149/)
- [Apple Documentation: Observation](https://developer.apple.com/documentation/observation)
- [Swift Evolution Proposal: SE-0395](https://github.com/apple/swift-evolution/blob/main/proposals/0395-observability.md)

---

## 待补充的技术主题

- [ ] Keychain 安全存储机制
- [ ] Swift Concurrency (async/await)
- [ ] URLSession 与网络请求
- [ ] Swift Package Manager 模块化架构
- [ ] JWT 认证流程
- [ ] SwiftUI 导航模式 (NavigationStack)
- [ ] 错误处理最佳实践

---

*最后更新：2025-10-12*
*项目：CatchTrend - iOS 股票策略应用*
